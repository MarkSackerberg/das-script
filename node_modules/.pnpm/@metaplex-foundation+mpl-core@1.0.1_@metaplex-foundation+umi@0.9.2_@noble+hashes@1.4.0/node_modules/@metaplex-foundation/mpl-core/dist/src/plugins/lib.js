"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseExternalPluginAdapterData = exports.pluginKeyToPluginType = exports.registryRecordsToPluginsList = exports.mapPlugin = exports.mapPluginFields = exports.pluginAuthorityPairV2 = exports.createPluginV2 = exports.pluginAuthorityPair = exports.createPlugin = exports.formPluginHeaderV1 = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const generated_1 = require("../generated");
const utils_1 = require("../utils");
const pluginAuthority_1 = require("./pluginAuthority");
const royalties_1 = require("./royalties");
const masterEdition_1 = require("./masterEdition");
function formPluginHeaderV1(pluginRegistryOffset) {
    return {
        key: generated_1.Key.PluginHeaderV1,
        pluginRegistryOffset,
    };
}
exports.formPluginHeaderV1 = formPluginHeaderV1;
function createPlugin(args) {
    // TODO refactor when there are more required empty fields in plugins
    if (args.type === 'UpdateDelegate') {
        return {
            __kind: args.type,
            fields: [
                args.data || {
                    additionalDelegates: [],
                },
            ],
        };
    }
    return {
        __kind: args.type,
        fields: [args.data || {}],
    };
}
exports.createPlugin = createPlugin;
function pluginAuthorityPair(args) {
    const { type, authority, data } = args;
    return {
        plugin: createPlugin({
            type,
            data,
        }),
        authority: authority ? (0, umi_1.some)(authority) : (0, umi_1.none)(),
    };
}
exports.pluginAuthorityPair = pluginAuthorityPair;
function createPluginV2(args) {
    // TODO refactor when there are more required empty fields in plugins
    const { type } = args;
    if (type === 'UpdateDelegate') {
        return {
            __kind: type,
            fields: [
                args || {
                    additionalDelegates: [],
                },
            ],
        };
    }
    if (type === 'Royalties') {
        return {
            __kind: type,
            fields: [(0, royalties_1.royaltiesToBase)(args)],
        };
    }
    if (type === 'MasterEdition') {
        return {
            __kind: type,
            fields: [(0, masterEdition_1.masterEditionToBase)(args)],
        };
    }
    return {
        __kind: type,
        fields: [args || {}],
    };
}
exports.createPluginV2 = createPluginV2;
function pluginAuthorityPairV2({ type, authority, ...args }) {
    return {
        plugin: createPluginV2({
            type,
            ...args,
        }),
        authority: authority ? (0, umi_1.some)((0, pluginAuthority_1.pluginAuthorityToBase)(authority)) : (0, umi_1.none)(),
    };
}
exports.pluginAuthorityPairV2 = pluginAuthorityPairV2;
function mapPluginFields(fields) {
    return fields.reduce((acc2, field) => ({ ...acc2, ...field }), {});
}
exports.mapPluginFields = mapPluginFields;
function mapPlugin({ plugin: plug, authority, offset, }) {
    const pluginKey = (0, utils_1.toWords)(plug.__kind)
        .toLowerCase()
        .split(' ')
        .reduce((s, c) => s + (c.charAt(0).toUpperCase() + c.slice(1)));
    if (plug.__kind === 'Royalties') {
        return {
            [pluginKey]: {
                authority,
                offset,
                ...(0, royalties_1.royaltiesFromBase)(plug.fields[0]),
            },
        };
    }
    if (plug.__kind === 'MasterEdition') {
        return {
            [pluginKey]: {
                authority,
                offset,
                ...(0, masterEdition_1.masterEditionFromBase)(plug.fields[0]),
            },
        };
    }
    return {
        [pluginKey]: {
            authority,
            offset,
            ...('fields' in plug ? mapPluginFields(plug.fields) : {}),
        },
    };
}
exports.mapPlugin = mapPlugin;
function registryRecordsToPluginsList(registryRecords, accountData) {
    return registryRecords.reduce((acc, record) => {
        const mappedAuthority = (0, pluginAuthority_1.pluginAuthorityFromBase)(record.authority);
        const deserializedPlugin = (0, generated_1.getPluginSerializer)().deserialize(accountData, Number(record.offset))[0];
        acc = {
            ...acc,
            ...mapPlugin({
                plugin: deserializedPlugin,
                authority: mappedAuthority,
                offset: record.offset,
            }),
        };
        return acc;
    }, {});
}
exports.registryRecordsToPluginsList = registryRecordsToPluginsList;
function pluginKeyToPluginType(pluginKey) {
    return (pluginKey.charAt(0).toUpperCase() +
        pluginKey.slice(1));
}
exports.pluginKeyToPluginType = pluginKeyToPluginType;
function parseExternalPluginAdapterData(plugin, record, account) {
    let data;
    const dataSlice = account.slice(Number(record.dataOffset), Number(record.dataOffset) + Number(record.dataLen));
    if (plugin.schema === generated_1.ExternalPluginAdapterSchema.Binary) {
        data = dataSlice;
    }
    else if (plugin.schema === generated_1.ExternalPluginAdapterSchema.Json) {
        data = JSON.parse(new TextDecoder().decode(dataSlice));
    }
    else if (plugin.schema === generated_1.ExternalPluginAdapterSchema.MsgPack) {
        // eslint-disable-next-line no-console
        console.warn('MsgPack schema currently not supported, falling back to binary');
        data = dataSlice;
    }
    return data;
}
exports.parseExternalPluginAdapterData = parseExternalPluginAdapterData;
//# sourceMappingURL=lib.js.map