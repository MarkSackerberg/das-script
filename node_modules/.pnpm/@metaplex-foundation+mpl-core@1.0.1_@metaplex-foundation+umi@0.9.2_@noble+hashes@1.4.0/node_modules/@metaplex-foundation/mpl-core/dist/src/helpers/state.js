"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAssetOwner = exports.isFrozen = exports.deriveAssetPlugins = exports.deriveExternalPluginAdapters = exports.getExternalPluginAdapterKeyAsString = exports.collectionAddress = void 0;
const umi_1 = require("@metaplex-foundation/umi");
/**
 * Find the collection address for the given asset if it is part of a collection.
 * @param {AssetV1} asset Asset
 * @returns {PublicKey | undefined} Collection address
 */
function collectionAddress(asset) {
    if (asset.updateAuthority.type === 'Collection') {
        return asset.updateAuthority.address;
    }
    return undefined;
}
exports.collectionAddress = collectionAddress;
const externalPluginAdapterKeys = [
    'oracles',
    'dataStores',
    'lifecycleHooks',
];
const getExternalPluginAdapterKeyAsString = (plugin) => {
    switch (plugin.type) {
        case 'Oracle':
            return `${plugin.type}-${plugin.baseAddress}`;
        case 'DataStore':
            return `${plugin.type}-${plugin.dataAuthority.type}${plugin.dataAuthority.address ? `-${plugin.dataAuthority.address}` : ''}`;
        case 'LifecycleHook':
        default:
            return `${plugin.type}-${plugin.hookedProgram}`;
    }
};
exports.getExternalPluginAdapterKeyAsString = getExternalPluginAdapterKeyAsString;
const deriveExternalPluginAdapters = (asset, collection) => {
    if (!collection) {
        return asset;
    }
    const externalPluginAdapters = {};
    externalPluginAdapterKeys.forEach((key) => {
        const set = new Set();
        if (asset[key] || collection[key]) {
            externalPluginAdapters[key] = [];
        }
        asset[key]?.forEach((plugin) => {
            set.add((0, exports.getExternalPluginAdapterKeyAsString)(plugin));
            externalPluginAdapters[key]?.push(plugin);
        });
        collection[key]?.forEach((plugin) => {
            if (!set.has((0, exports.getExternalPluginAdapterKeyAsString)(plugin))) {
                externalPluginAdapters[key]?.push(plugin);
            }
        });
    });
    return externalPluginAdapters;
};
exports.deriveExternalPluginAdapters = deriveExternalPluginAdapters;
/**
 * Derive the asset plugins from the asset and collection. Plugins on the asset take precedence over plugins on the collection.
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {AssetV1} Asset with plugins
 */
function deriveAssetPlugins(asset, collection) {
    if (!collection) {
        return asset;
    }
    const externalPluginAdapters = (0, exports.deriveExternalPluginAdapters)(asset, collection);
    return {
        ...{
            ...collection,
            masterEdition: undefined, // master edition can only be on the collection
        },
        ...asset,
        ...externalPluginAdapters,
    };
}
exports.deriveAssetPlugins = deriveAssetPlugins;
/**
 * Check if the asset is frozen.
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the asset is frozen
 */
function isFrozen(asset, collection) {
    const dAsset = deriveAssetPlugins(asset, collection);
    return (dAsset.freezeDelegate?.frozen ||
        dAsset.permanentFreezeDelegate?.frozen ||
        false);
}
exports.isFrozen = isFrozen;
/**
 * Check if the given pubkey is the owner of the asset.
 * @param {string | PublicKey} pubkey Pubkey
 * @param {AssetV1} asset Asset
 * @returns {boolean} True if the pubkey is the owner
 */
function isAssetOwner(pubkey, asset) {
    const key = (0, umi_1.publicKey)(pubkey);
    return key === asset.owner;
}
exports.isAssetOwner = isAssetOwner;
//# sourceMappingURL=state.js.map